#ifndef mirv_Core_Filter_AttributeManager_hpp
#define mirv_Core_Filter_AttributeManager_hpp

#include <mirv/Core/Containers/Vector.hpp>

namespace mirv {
  /// The AttributeManager tracks inherited and synthesized attributes
  /// used during flow execution.  Each visited node can query its
  /// inherited attribute and can set synthesized attributes for its
  /// parent to inspect.  Multiple attributes may be set by packaging
  /// them in an aggregate.  Attributes should be relatively
  /// lightweight and must be default-constructable.  Wrapping
  /// heavyweight attributes in ptr<> is appropriate.
  ///
  /// The AttributeManager follows the following convention:
  ///
  /// Parent nodes own the attribute context for their child nodes.
  /// This means that upon entry to a node, we must push a new
  /// attribute context.  The parent can then set an inherited
  /// attributes for each child without reallocating an attribute
  /// context.  Child nodes send their synthesized attributes back to
  /// the parent using the attribute context the parent created.
  template<typename Inherited, typename Synthesized = Inherited>
  class AttributeManager {
s  private:
    /// This is the record type for recording inherited and
    /// synthesized attributes.
    class AttributeRecord {
      Inherited inherited;
      Synthesized synthesized;

    public:
      void setInheritedAttribute(const Inherited &inh) {
        inherited = inh;
      }

      void setSynthesizedAttribute(const Synthesized &syn) {
        synthesized = syn;
      }

      const Inherited &getInheritedAttribute(void) const {
        return inherited;
      }

      const Synthesized &getSynthesizedAttribute(void) const {
        return synthesized;
      }
    };

    typedef typename Vector<AttributeRecord>::type AttributeStackType;
    AttributeStackType attributeStack;

  public:
    void pushAttributeContext(void) {
      attributeStack.push_back(AttributeRecord());
    }

    void popAttributeContext(void) {
      attributeStack.pop_back();
    }

    /// Set an inherited attribute for the child node we are about to
    /// visit.
    void setInheritedAttribute(const Inherited &inherited) {
      attributeStack.back().setInheritedAttribute(inherited);
    }

    /// Set a synthesized attribute for the parent we are about return
    /// to.
    void setSynthesizedAttribute(const Synthesized &synthesized) {
      attributeStack.back().setSynthesizedAttribute(synthesized);
    }

    /// Get the inherited attribute for this node,
    const Inherited &getInheritedAttribute(void) const {
      return attributeStack.back().getInheritedAttribute();
    }

    /// Get the synthesized attribute generated by the child just
    /// visited.
    const Symthesized &getSynthesizedAttribute(void) const {
      return attributeStack.back().getSynthesizedAttribute();
    }
  };
}

#endif
