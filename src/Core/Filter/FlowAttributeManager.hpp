#ifndef mirv_Core_Filter_FlowAttributeManager_hpp
#define mirv_Core_Filter_FlowAttributeManager_hpp

#include <mirv/Core/Containers/Vector.hpp>
#include <mirv/Core/Utility/Debug.hpp>

namespace mirv {
  /// The FlowAttributeManager tracks inherited and synthesized attributes
  /// used during flow execution.  Each visited node can query its
  /// inherited attribute and can set synthesized attributes for its
  /// parent to inspect.  Multiple attributes may be set by packaging
  /// them in an aggregate.  Attributes should be relatively
  /// lightweight.
  ///
  /// The FlowAttributeManager follows the following convention:
  ///
  /// Parent nodes own the attribute context for their child nodes.
  /// This means that upon entry to a node, we must push a new
  /// attribute context.  The parent can then set an inherited
  /// attributes for each child without reallocating an attribute
  /// context.  Child nodes send their synthesized attributes back to
  /// the parent using the attribute context the parent created.
  template<typename Inherited, typename Synthesized = Inherited>
  class FlowAttributeManager {
  private:
    /// This is the record type for recording inherited and
    /// synthesized attributes.
    class AttributeRecord {
    private:
      Inherited inherited;
      Synthesized synthesized;
      bool setSynth;

    public:
      AttributeRecord(void) {}
      AttributeRecord(const Inherited &inh)
          : inherited(inh), synthesized(), setSynth(false) {}

      void setInheritedAttribute(const Inherited &inh) {
        inherited = inh;
      }

      void setSynthesizedAttribute(const Synthesized &syn) {
        synthesized = syn;
        setSynth = true;
      }

      const Inherited &getInheritedAttribute(void) const {
        return inherited;
      }

      const Synthesized &getSynthesizedAttribute(void) const {
        return synthesized;
      }

      bool setSynthesized(void) const {
        return setSynth;
      }
    };

    typedef typename Vector<AttributeRecord>::type AttributeStackType;
    AttributeStackType attributeStack;

  public:
    FlowAttributeManager(const Inherited &inherited) {
      attributeStack.push_back(AttributeRecord(inherited));
    }

    template<typename Manager>
    void swap(Manager &other) {
      attributeStack.swap(other.attributeStack);
    }

    void pushContext(void) {
      bool initialized = !attributeStack.empty();
      attributeStack.push_back(AttributeRecord());
      // Copy inherited attributes down by default.
      if (initialized) {
        setInheritedAttribute(getInheritedAttribute());
      }
    }

    void popContext(void) {
      checkInvariant(attributeStack.size() > 1, "Attribute stack underflow");
      if (!(attributeStack.end() - 2)->setSynthesized()) {
        // Copy synthesized attributes up by default.
        setSynthesizedAttribute(getSynthesizedAttribute());
      }
      attributeStack.pop_back();
    }

    /// Set an inherited attribute for the child node we are about to
    /// visit.
    void setInheritedAttribute(const Inherited &inherited) {
      checkInvariant(!attributeStack.empty(), "Attribute stack underflow");
      attributeStack.back().setInheritedAttribute(inherited);
    }

    /// Set a synthesized attribute for the parent we are about return
    /// to.  Since we pushed a child attribute context, our
    /// synthesized attribute actually goes one back from the top of
    /// the stack.
    void setSynthesizedAttribute(const Synthesized &synthesized) {
      checkInvariant(attributeStack.size() > 1, "Attribute stack underflow");
      (attributeStack.end() - 2)->setSynthesizedAttribute(synthesized);
    }

    /// Get the inherited attribute for this node, Since we pushed a
    /// child attribute context, our inherited attribute is actually
    /// one back from the top of stack.
    const Inherited &getInheritedAttribute(void) const {
      checkInvariant(attributeStack.size() > 1, "Attribute stack underflow");
      return (attributeStack.end() - 2)->getInheritedAttribute();
    }

    /// Get the synthesized attribute generated by the child just
    /// visited.
    const Synthesized &getSynthesizedAttribute(void) const {
      checkInvariant(!attributeStack.empty(), "Attribute stack underflow");
      return attributeStack.back().getSynthesizedAttribute();
    }
  };
}

#endif
